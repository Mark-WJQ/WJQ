package com.wjq.algorithm.enumeration;

import java.util.Arrays;

/**
 *
 * 拨钟问题
 * 有9个时钟，排成一个3*3的矩阵。
 * |-------|    |-------|    |-------|
 * |       |    |       |    |   |   |
 * |---O   |    |---O   |    |   O   |
 * |       |    |       |    |       |
 * |-------|    |-------|    |-------|
 *     A            B            C
 *
 * |-------|    |-------|    |-------|
 * |       |    |       |    |       |
 * |   O   |    |   O   |    |   O   |
 * |   |   |    |   |   |    |   |   |
 * |-------|    |-------|    |-------|
 *     D            E            F
 *
 * |-------|    |-------|    |-------|
 * |       |    |       |    |       |
 * |   O   |    |   O---|    |   O   |
 * |   |   |    |       |    |   |   |
 * |-------|    |-------|    |-------|
 *     G            H            I
 *
 *  现在需要用最少的移动，将9个时钟的指针都拨到12点的位置。共允许有9种不同的移动。
 *  如下所示，每个移动会将若干个时钟的指针沿顺时针方向拨动90度。
 *  移动      影响的时钟
 *  1         	ABDE
 *  2			ABC
 *  3			BCEF
 *  4			ADG
 *  5			BDEFH
 *  6			CFI
 *  7			DEGH
 *  8			GHI
 *  9			EFHI
 *
 * 输入
 * 9个整数，表示各时钟指针的其实位置，相邻两个整数之间用单个空格隔开。其中，
 * 0 =12点，1=3点，2=6点，3=9点
 * 输出
 * 输出一个最短的移动序列，是的9个时钟的指针都指向12点，按照移动的序号从小到达输出结果
 * 相邻两个整数之间用单个空格隔开。
 * 样例输入
 * 3 3 0
 * 2 2 2
 * 2 1 2
 *
 * 样例输出
 * 4 5 8 9
 *
 *
 * 解题思路
 * 类似于熄灯问题，通过对局部解决方案枚举确定，剩下的情况就只剩下一种或有限集中方案便可确定解决
 * 通过分析，我们可以通过操作1,2,3 种移动方式，来枚举第一行的各种状态。
 * 第一种移动方式 影响A
 * 第二种移动方式影响B
 * 第三种移动方式影响C
 * 第一行的状态是有限的，每个时钟有四个状态，同一种移动方式操作四次以后相当于又回到初始状态，所以在第一行对于三种移动方式的枚举状态总共有 4^3 = 64种
 *
 *首先明确思路使用枚举的方法解题，虚招合适的枚举方法，我们可以通过暴力枚举，即使用9重嵌套来解题，单核心思路是在尽量减少枚举数量的前提下解题，所以可以思考一下。
 * 类似熄灯问题，通过对局部解决方案枚举确定，剩下的情况就只剩下一种或有限集中方案便可确定解决。同事也需要注意在解题的过程中，控制变量变化的数量，变量变化的数量在一个时解题比较容易确定
 * 可以将移动方式与时钟的对应关系如下表示
 * A  1,2,4
 * B  1,2,3,5
 * C  2,3,6
 * D  1,4,5,7
 * E  1,3,5,7,9
 * F  3,5,7,9
 * G  4,7,8
 * H  5,7,8,9
 * I  6,8,9
 *
 * 可以看到，假设我们将 第1,2,3中移动方式作为初始状态来进行枚举，则A 只有第4种移动可以确定，B 通过第5种确定，C通过第6种确定，变量唯一
 * A，B,C 确定以后，移动方式1,2,3,4,5,6 的初始状态也就确定了，以此类推后续的 D  通过第7种，F 通过第9种。
 * 此时剩下E，H，I,G 尚未确定，移动方式1,2,3,4,5，6,7,9 已经初始化。所以 E 此时也可以确定。
 * 又因为第8种移动方式可以同时影响G,H,I,此时只需观察G,I,H，是否在同一位置即可，如果在，则计算移动8，应该移动几步。
 *
 *
 *
 *
 * @author wangjianqiang24
 * @date 2020/10/27
 */
public class SetTheClock {


	int move[] = {0, 0, 0, 0, 0, 0, 0, 0, 0};

	int[] enumration() {
		while (judge(m[0], m[1], m[2]) != 0) {
			m[0]++;
			int i = 0;
			while (m[i] > 3) {
				m[i] = 0;
				i++;
				m[i]++;
			}
		}

		return null;
	}


	int block[] = {3, 3, 0, 2, 2, 2, 2, 1, 2};

	private int judge(int a, int b, int c) {
		move = Arrays.copyOf(m, m.length);
		//先判断A，在确定了使用1,2,3 移动方式后，只有第四种可以影响A
		int r = 0;
		for (; move[3] < 4; move[3]++) {
			r = (block[0] + a + b + move[3]) % 4;
			if (r == 0) {
				break;
			}
		}
		if (r != 0) {
			return r;
		}
		//接下来判断B，可以影响B的移动方式1,2,3,5，应该为1，2,3 已经固定，所以目前影响B的只有5
		for (; move[4] < 4; move[4]++) {
			r = (block[1] + a + b + c + move[4]) % 4;
			if (r == 0) {
				break;
			}
		}
		if (r != 0) {
			return r;
		}
		//接下来 C ，2,3,6, 2,3已经确定所以只要变化6 就可以
		for (; move[5] < 4; move[5]++) {
			r = (block[2] + b + c + move[5]) % 4;
			if (r == 0) {
				break;
			}
		}
		if (r != 0) {
			return r;
		}
		//此时4,5,6 移动方式也已经确定。共确定1,2,3,4,5,6，那我们此时看D = 1,4,5,7
		for (; move[6] < 4; move[6]++) {
			r = (block[3] + a + move[3] + move[4] + move[6]) % 4;
			if (r == 0) {
				break;
			}
		}
		if (r != 0) {
			return r;
		}


		//F = 3,5,7,9
		for (; move[8] < 4; move[8]++) {
			r = (block[5] + c + move[4] + move[6] + move[8]) % 4;
			if (r == 0) {
				break;
			}
		}

		if (r != 0) {
			return r;
		}

		//E = 1,3,5,7,9
		r = (block[4] + a + c + move[4] + move[6] + move[8]) % 4;
		if (r != 0) {
			return r;
		}


		//此时只剩GHI没有确定，但是第8种移动方式可同时影响GHI，所以此时可以首先确认GHI是不是相等，然后确定移动步骤
		//G = 4,7,8
		int g = block[6] + move[3] + move[6];
		//H = 5,7,8,9
		int h = block[7] + move[4] + move[6] + move[8];
		//I=6,8,9
		int i = block[8] + move[5] + move[8];
		if (g != h || g != i) {
			return g;
		}
		//如果g,h,i 相等，移动第8种方式
		move[7] = (4 - g) % 4;


		return 0;

	}


	public static void main(String[] args) {


		SetTheClock clock = new SetTheClock();
		clock.enumration();
		for (int i = 0; i < 9; i++) {
			while (clock.move[i]-- != 0)
				System.out.println(i+1);
		}
	}




	int m[] = {0, 0, 0, 0, 0, 0, 0, 0, 0};


	int b[] = {3, 3, 0, 2, 2, 2, 2, 1, 2};


	/**
	 * 这种方式是想通过确定第1种移动方式来确定后续的动作，如果想要是的A的位置变为0，则需要2,4 两种方式共同作用，这样变量多，嵌套层数也比较多
	 * 以下程序有问题
	 * @return
	 */
	int[] a() {

		for (; m[0] < 4; m[0]++) {
			int sum = 0;
			//对时钟A求0，在一次遍历中可能会出现多次满足0的条件，在满足0的条件下需要嵌套查看后续移动方式是否满足
			for (; m[1] < 4; m[1]++) {
				for (; m[3] < 4; m[3]++) {
					int r = (b[0] + m[0] + m[1] + m[3]) % 4;
					if (r != 0) {
						continue;
					}
					else {
						//todo 需要检查 B 满足0的条件
						break;
					}
				}
			}
			//对时钟B求0
			for (; m[2] < 4; m[2]++) {
				for (; m[4] < 0; m[4]++) {
					int r = (b[1] + m[0] + m[1] + m[2] + m[4]) % 4;
					if (r != 0) {
						continue;
					}
				}
			}

			//对时钟C求0
			for (; m[5] < 4; m[5]++) {
				int r = (b[2] + m[1] + m[2] + m[5]) % 4;
				if (r != 0) {
					continue;
				}
			}

			//对时钟D求0
			for (; m[6] < 4; m[6]++) {
				int r = (b[3] + m[0] + m[3] + m[4] + m[6]) % 4;
				if (r != 0) {
					continue;
				}
			}

			//对时钟E求0
			int r1 = (b[4] + m[0] + m[2] + m[4] + m[6]) % 4;
			if (r1 != 0) {
				continue;
			}

			//对时钟F求0
			for (; m[8] < 4; m[8]++) {
				int r = (b[5] + m[6] + m[2] + m[4] + m[8]) % 4;
				if (r != 0) {
					continue;
				}
			}

			//对时钟G求0
			for (; m[7] < 4; m[7]++) {
				int r = (b[6] + m[3] + m[6] + m[7]) % 4;
				if (r != 0) {
					continue;
				}
			}


			//对时钟H求0
			int r2 = (b[7] + m[4] + m[6] + m[7] + m[8]) % 4;
			if (r2 != 0) {
				continue;
			}


			//对时钟I求0
			int r3 = (b[8] + m[5] + m[7] + m[8]) % 4;
			if (r3 != 0) {
				continue;
			}
		}
		return null;

	}


	/**
	 * 确定1,2,3种方案的移动
	 * @param a 第一种移动的次数
	 * @param b 第二种移动的次数
	 * @param c 第三种移动的系数
	 * @return
	 */
	public int[] operate(int a, int b, int c) {


		return null;
	}


	public void setClock(int[] a) {


	}

}
