package com.wjq.algorithm.dynamic;

//一条包含字母 A-Z 的消息通过以下方式进行了编码：
//
//
//'A' -> 1
//'B' -> 2
//...
//'Z' -> 26
//
//
// 给定一个只包含数字的非空字符串，请计算解码方法的总数。
//
// 题目数据保证答案肯定是一个 32 位的整数。
//
//
//
// 示例 1：
//
//
//输入：s = "12"
//输出：2
//解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
//
//
// 示例 2：
//
//
//输入：s = "226"
//输出：3
//解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
//
//
// 示例 3：
//
//
//输入：s = "0"
//输出：0
//
//
// 示例 4：
//
//
//输入：s = "1"
//输出：1
//
//
// 示例 5：
//
//
//输入：s = "2"
//输出：1
//
//
//
//
// 提示：
//
//
// 1 <= s.length <= 100
// s 只包含数字，并且可能包含前导零。
//

/**
 *
 * @author wangjianqiang24
 * @date 2020/12/9
 */
public class Decode {


	public static void main(String[] args) {
		Decode d = new Decode();
		System.out.println(d.numDecodings("10"));
	}


	/**
	 * 解法
	 * 首先分解问题，可以参考走楼梯案例，先看一个数字，再看一个数字，因为最大是26，所以在看的时候是有条件的
	 * 确定状态 很明显方案个数只与字符串长度相关  i
	 * 初始状态  r(1) = 1,r(0) =1 因为字符串为空的时候其实也有一种解法那就是没有
	 * 状态转移方程
	 *  在决定当前位置i有多少种摆法时，需要参考位置 i-2 有多少种摆法
	 *
	 *  假定a[i-2] 位置能摆放k种结果
	 *  如果a[i-1] != 1,2
	 *   a[i-1] 的位置就有k种结果，因为它并不能与i-2拼成一个字符，只是单纯的新增一个字符
	 *
	 *   假定a[i-1] == 1 || (a[i-1] == 2 && 0<= a[i] <=6) 即两个字符拼起来<=26
	 *   首先r[i] 包含 r[r-1] 种结果，其次再加上a[i-1]与a[i] 组成的字符结果数，这个结果数就是r[i-2]
	 *  eg：字符串 1123
	 *  11    1,1    ; 11;
	 *  112   1,1,2  ; 11,2  ; 1,12  ;
	 *  1123  1,1,2,3; 11,2,3; 1,12,3;1,1,23;11,23;
	 *
	 *  从例子中可以看出每次新增一个数字时，都是首先在上一个的基础上扩展一下r[i-1]，然后再看最后两个数字能否拼成一个新的字符如果能就是r[i-2],r[i-1]中最后一个是单字符的个数是r[i-2]，r[i] = r[i-1] + r[i-2]
	 *  再加上0的条件判断
	 *
	 *
	 *
	 * @param s
	 * @return
	 */
	public int numDecodings(String s) {
		int l = s.length();
		if (l == 0) {
			return 0;
		}
		int[] result = new int[l + 1];
		char c = s.charAt(0);
		result[0] = 1;
		if (c > '0') {
			result[1] = 1;
		}
		for (int i = 1; i < l; i++) {
			c = s.charAt(i);
			char pre = s.charAt(i - 1);
			if (c == '0'){
				if (pre != '1' && pre != '2'){
					return 0;
				}
				result[i+1] = result[i-1];
				continue;
			}
			if (pre == '1' || (pre == '2'&& '0' <= c && c <= '6' )){
				result[i+1] = result[i] + result[i-1];
				continue;
			}
			result[i+1] = result[i];
		}
		return result[l];

	}
}
